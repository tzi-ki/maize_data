### Data from B73 and Mo17 maize strains ###
### Leaves Extracts ###

# Set your working directory
setwd("C:/Users/")

# Download the data into your working directory
# https://doi.org/10.5281/zenodo.4056710

# Install the libraries needed
if (!require("MALDIquant")) install.packages("MALDIquant")
if (!require("MALDIquantForeign")) install.packages("MALDIquantForeign")
if (!require("pheatmap")) install.packages("pheatmap")
if (!require("factoextra")) install.packages("factoextra")
if (!require("tidyselect")) install.packages("tidyselect")

# Load the libraries
library(MALDIquant)
library(MALDIquantForeign)
library(pheatmap)
library(factoextra)

#############################
### Mass Spectra Analysis ###
#############################

# Files list
mzML_list<-list.files(pattern = "*.mzML")
mzML_list

# Import Data & Sum Scans
filecounter<-1
spectrum<-list()
mzMLno<-length(mzML_list)
while (filecounter<=mzMLno){
  mzML_filename<-mzML_list[filecounter]
  print(mzML_filename)
  importspectrum <- import(mzML_filename)
  sumspectrum <- averageMassSpectra(importspectrum, method="sum")
  spectrum[[filecounter]]<-sumspectrum
  print(filecounter)
  filecounter<-filecounter+1
}

## Using MALDIquant package ##
# Calibrate intensity
spectrum_cI_tic <- calibrateIntensity(spectrum, method="TIC")

plot(spectrum[[1]])
plot(spectrum_cI_tic[[1]])

# Signal to noise
peaks <- detectPeaks(spectrum_cI_tic)
peaks

# Peak picking
warpingFunctions<-determineWarpingFunctions(peaks)
peaks<-warpMassPeaks(peaks,warpingFunctions)

# Binning
peaks <- binPeaks(peaks)

# Peak filtering
peaks <- filterPeaks(peaks, minFrequency=0.5)

#Generate the Feature Matrix
samplenames<-gsub(".mzML","",mzML_list)
featureMatrix <- intensityMatrix(peaks)
featureMatrix <- as.data.frame(featureMatrix)
rownames(featureMatrix)<-samplenames
colnames(featureMatrix)<-colnames(featureMatrix)
featureMatrix[is.na(featureMatrix)] <- 0
write.csv(featureMatrix,"FeatureMatrix_TIC.csv")

#Find maximal value for each column (mz-bin)
columnmax<-apply(featureMatrix, 2, max)

#Sort and select the most intense values
colmax<-sort(columnmax,decreasing=TRUE)
colmaxselection<-as.matrix(colmax[1:20])
colmaxselection=as.vector(rownames(colmaxselection))

#Limiting matrix to selection
max_normout_featureMatrix<-featureMatrix[,colmaxselection]
t_max_normout_featureMatrix<-t(max_normout_featureMatrix)


#############################
###   Data visualization  ###
#############################

## Heatmap ##
pheatmap(t_max_normout_featureMatrix) #default
# Heatmap (distance measure: correlation, and linkage method: complete) 
pheatmap((t_max_normout_featureMatrix),scale="row",cluster_cols = TRUE, cluster_rows = TRUE, clustering_distance_rows="correlation", clustering_distance_cols="correlation", clustering_methode="complete",cellwidth = 16, cellheight = 18, fontsize=10)


## PCA ##
#Calculate kmeans
km.out <- kmeans(featureMatrix, centers = 2, nstart = 20, iter.max = 50) 
km.out$cluster

pca1=prcomp(featureMatrix)

#Plot PCA
dim1<- fviz_pca_ind(pca1,  axes = c(1,2), 
                    col.ind = factor(km.out$cluster),
                    addEllipses= T,
                    repel = T,
                    legend.title = "Genotype")


dim1


#############################
###     Data mining       ###
#############################

## Random Forest ##
#create dataframe for the Random Forest Model
IonFrame=as.data.frame(featureMatrix)
#correct colnames
colnames(IonFrame)=paste("mz", colnames(IonFrame), sep="")
#Create Variable of interest
IonFrame$InbredLine=as.factor(substr(colnames(t(featureMatrix)), start=1, stop=4))

## First option ##
## The Rattle package option ##
# This R package is a Graphical User Interface for Data Science,
# that enables you to do multiple types of analyzes, Random Forest is one of them.

# Install and load rattle package
if (!require("rattle")) install.packages("rattle") #The installation may lasts several minutes
library(rattle)
# Open rattle
rattle() 
# After the GUI opens go to the Data tab, 
# Select on the source section the R Dataset option, 
# Then choose the option "IonFrame" and click onn the Execute tab to load it
# After loading your data, go to the Model tab
# and select the option "Forest" and click on Execute tab to obtain the results.

## Second option ##
## The direct option, without rattle GUI ##
# Using directly the R package randomForest #
if (!require("randomForest")) install.packages("randomForest")
library(randomForest)
# Generate Random Forest model #
set.seed(42)
Ionmatrix.rf  <- randomForest(InbredLine ~ ., data=IonFrame, importance=TRUE, proximity=TRUE)
print(Ionmatrix.rf)
IMP=as.data.frame(importance(Ionmatrix.rf)) #obtain data frame
IMP=IMP[order(IMP$MeanDecreaseGini, decreasing = TRUE),]    #order according MeanDecreaseGini
IMP[1:50,]      #list the 50 most discriminant Ions

#Create heatmaps using variables with the highest gini 

row.names(IMP)<-substr((row.names(IMP)),3,18) # eliminate mz 
SelIonRF= rownames(t(featureMatrix)) %in% rownames(IMP[1:20,])# 20 variables
pheatmap(t(featureMatrix[,SelIonRF]),scale="row",cluster_cols = TRUE, cluster_rows = TRUE, clustering_distance_rows="correlation", clustering_distance_cols="correlation", clustering_methode="complete",cellwidth = 16, cellheight = 18, fontsize=10)
